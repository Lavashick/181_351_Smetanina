// Работа с ФАЙЛАМИ
// #include <cstring>// strcat(), strlen(), strcmp()
#include <iostream>
#include <fstream>
#include <string>
using namespace std;

// Открываем файл "тест":

int main() {
	setlocale(LC_ALL, "Russian"); // Делаем поддержку русского языка 


	fstream file_dop;
	file_dop.open("dop.txt", fstream::out); // Пишем аут, когда будем записывать что-то в файл

	if (!file_dop) // Проверка на то, открылся ли файл или нет
	{
		cout << "Файл не открыт" << endl;
	}
	else
	{
		cout << "Все ОК! Файл открыт!" << endl;
	}

	ifstream file; // Объявляем сам этот файл
	file.open("test.txt", fstream::in); // Открываем файл. Перед in писать fstream::
	// Пишем ин, когда надо записать что-то из файла

	if (!file) // Проверка на то, открылся ли файл или нет
	{
		cout << "Файл не открыт" << endl;
	}
	else
	{
		cout << "Все ОК! Файл открыт!" << endl;
	}
    /* Второй вариант проверки на открытие файла
	if (file.is_open()) // вызов метода is_open()
	cout << "Все ОК! Файл открыт!\n\n" << endl;
	else
	{
	cout << "Файл не открыт!\n\n" << endl;
	return -1;
	}
	*/

	/*
	getline(); get() - считывание строки

	Считка строки из текста

	string s;
	getline(file, s); // getkine(Класс, из которого берем строку из файла, в какую переменную будем ее записывать);
	cout << s << endl;


	Метод	Описание
	open	Открывает файл для чтения
	get	Читает один или более символов из файла
	getline	Читает символьную строку из текстового файла или данные из бинарного файла до определенного ограничителя
	read	Считывает заданное число байт из файла в память
	eof	Возвращает ненулевое значение (true), когда указатель потока достигает конца файла
	peek	Выдает очередной символ потока, но не выбирает его
	seekg	Перемещает указатель позиционирования файла в заданное положение
	tellg	Возвращает текущее значение указателя позиционирования файла
	close	Закрывает файл

	Чар
	 int n = 10;
	//Создаем буффер для чтения
	char* buffer = new char[n+1];
		buffer[n]=0;
	//Читаем n символов
	 file.get(buffer,n);
	//Или так, но до первого пробела
	file.getline(buffer,n,' ');
	//выводим считанное
	cout << buffer;
	//Освобождаем буффер
	 delete [] buffer;
	*/
	string string_from_file;
	getline(file, string_from_file);
	cout << string_from_file << endl;
	file.close();

	// Записывание в файл:
	file_dop << "Еще немного данных вот это конечно мдаа";
	file_dop.close();



}








/*
ifstream file;
file.open("test.txt", ios::in | ios::binary);
Оператор логического ИЛИ(| ) позволяет составить режим с любым сочетанием флагов.Так, чтобы, открывая файл по записи, случайно не затереть существующий файл с тем же именем, надо использовать следующую форму :

ofstream file;
file.open("test.txt", ios::out | ios::app);
Предполагается, что к проекту подключён соответствующий заголовочный файл :

#include <fstream.h>
Для проверки того удалось ли открыть файл, можно применять конструкцию

if (!file) {
	//Обработка ошибки открытия файла



*/

/*
Строки и файлы
строки старого С-типа представляют из себя всего лишь массив
символов с нулевым окончанием:
char cstr1[] = "C-style string1";
char cstr2[] = { 'C', '-', 's', 't', 'y', 'l', 'e', ' ', 's', 't', 'r', 'i', 'n', 'g', '1', '\0' };
char cstr3[] = {'\67', '\0'};
std::string cppstr1 = "C++ - style string 1";
std::string cppstr2 = "";

 в типе char на самом деле хранится знаковое целое число. Можно
 складывать делить умножать char
 Чтобы придать смысл данным, хранимым в char, нужна таблица
 соответствия чисел с символами - кодовая таблица (ASCII, ANSI, UNICODE)
 ФУНКЦИИ ДЛЯ РАБОТЫ С С-СТРОКАМИ
 вывод на печать printf(char[], , ,) или printf(* char, ...) -
 print formatted
 с помощью printf можно не просто печатать готовую строку, но и
 подставлять в неё другие переменные, попутно преобразовывая их
 в символьный вид и применяя форматирование
 форматирование printf("базовая %s строка %f, параметр1, параметр2)
 позиции, куда будут подставляться параметры, обозначаетются в
 базовой строке символом %
 значение символов форматирования берётся из таюблицы справки к
 функции http://www.cplusplus.com/reference/cstdio/printf/
 значения некоторых из них:
 %f - параметр подставляется на место %f, оформленное в виде числа с
 плавающей точкой
 %s - параметр подставляется на место %s, как строка
 %d - параметр подставляется на место %d, как целое число
 %e - параметр подставляется на место %e как число в
 экспоненциальном виде
 объединение (конкатенация) строк strcat(char*, char*)
 копирование из одной строки в другую strcpy()
 сравнение strcmp()
 длина строки strlen()
 вставка строки в подстроку производится в несколько действий
 в стандартной библиотеке C++ массив символови инкапсулирован в
 класс std::string
 в который так же собраны самые часто используемые методы обработки
 и для которого перегружены операторы + (конкатенация), ввод, вывод, ==,
 = и т.д.
 ещё одно отличие от строк С - длина строки теперь задаётся определенным
 числом, а не нклевым окончанием
 Цикл работы с файлом заключается в
 0.1 Проверить существует ли файл (в случае если нужно)
 0.2 При работу в C++ создать объект для работы с файлом
 1.Открытие файла
 2.Работа с файлом (чтение, запись, поиск)
 3.Закрытие файла
 */
